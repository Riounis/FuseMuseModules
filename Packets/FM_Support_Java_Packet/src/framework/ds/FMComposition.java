package framework.ds;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.SortedMap;
import java.util.TreeMap;

import jm.music.data.Score;

/**
 * Data structure for Driver Modules and Packets, used to hold information about the patterns,
 * rhythms, chord progressions, time signatures, keys, and tempo of an entire composition.
 */
public class FMComposition implements Iterable<FMMeasure>{
	
	// map from strings to composition segments
	private Map<String, FMCompositionSegment> segmentDictionary;
	
	// list of strings used to represent different segments of the composition
	private List<String> pattern;
	
	// score which stores parts generated by Packets
	private Score score;
	
	/**
	 * Constructs an FMComposition object
	 */
	public FMComposition() {
		segmentDictionary = new HashMap<>();
		pattern = new ArrayList<>();
		score = new Score();
	}
	
	/**
	 * Returns the score of the composition, containing all parts
	 * @return score
	 */
	public Score getScore() { return score; }
	
	/**
	 * Adds a composition segment to the pattern. For this to function properly, the corresponding
	 * composition segment must already be registered to the map of composition segment names using
	 * the registerCompositionSegment function.
	 * @param name of composition segment
	 */
	public void addCompositionSegment(String name) {
		if(segmentDictionary.containsKey(name)) {
			pattern.add(name);
		} else {
			throw new IllegalArgumentException("Segment name " + name + " not registered (be sure to call registerCompositionSegment before adding segments!)");
		}
	}
	
	/**
	 * Adds composition segments to the pattern. For this to function properly, the corresponding
	 * composition segments must already be registered to the map of composition segment names using
	 * the registerCompositionSegment function.
	 * @param name of composition segment
	 */
	public void addCompositionSegments(List<String> names) {
		for(String name : names) {
			if(segmentDictionary.containsKey(name)) {
				pattern.add(name);
			} else {
				throw new IllegalArgumentException("Segment name " + name + " not registered (be sure to call registerCompositionSegment before adding segments!)");
			}
		}
	}
	
	/**
	 * Registers the given composition segment to be referenced by the given name
	 * @param name of segment
	 * @param segment
	 */
	public void registerCompositionSegment(String name, FMCompositionSegment segment) {
		segmentDictionary.put(name, segment);
	}

	/**
	 * Returns a list of strings which are names of composition segments, or parts of the composition.
	 * @return pattern
	 */
	public List<String> getPattern() {
		return Collections.unmodifiableList(pattern);
	}
	
	/**
	 * Returns the list of composition segments contained by this composition.
	 * @return compositionSegments
	 */
	public List<FMCompositionSegment> getCompositionSegments() {
		List<FMCompositionSegment> res = new ArrayList<>();
		for(String name : pattern) {
			res.add(segmentDictionary.get(name));
		}
		return res;
	}
	
	/**
	 * Returns a map of all notes starting points and durations within the composition.
	 * @return rhythm
	 */
	public SortedMap<Integer, Integer> getRhythm() {
		List<FMCompositionSegment> segments = getCompositionSegments();
		SortedMap<Integer, Integer> res = new TreeMap<>();
		int currentSegmentStartPosition = 0;
		for(FMCompositionSegment fmcs: segments) {
			SortedMap<Integer, Integer> segmentRhythm = fmcs.getRhythm();
			for(Integer startInSegment : segmentRhythm.keySet()) {
				res.put(startInSegment + currentSegmentStartPosition,
						segmentRhythm.get(startInSegment));
			}
			currentSegmentStartPosition += fmcs.getDuration();
		}
		return res;
	}
	
	/**
	 * Returns all pitches at the given position (in FMNote rhythm value units) in the composition.
	 * @param position
	 * @return pitches
	 */
	public Collection<Integer> getPitchesAtPosition(int position) {
		List<FMCompositionSegment> segments = getCompositionSegments();
		int currentSegmentStartPosition = 0;
		for(FMCompositionSegment fmcs: segments) {
			if(position >= currentSegmentStartPosition &&
					position < currentSegmentStartPosition + fmcs.getDuration()) {
				return fmcs.getPitchesAtPosition(position - currentSegmentStartPosition);
			}
			currentSegmentStartPosition += fmcs.getDuration();
		}
		return Collections.emptyList();
	}
	
	/**
	 * Returns the remaining duration in the current measure (in FMNote rhythm value units).
	 * @param position
	 * @return duration
	 */
	public int getRemainingMeasureDurationAtPosition(int position) {
		List<FMCompositionSegment> segments = getCompositionSegments();
		int currentSegmentStartPosition = 0;
		for(FMCompositionSegment fmcs: segments) {
			if (position >= currentSegmentStartPosition &&
					position < currentSegmentStartPosition + fmcs.getDuration()) {
				return fmcs.getRemainingMeasureDurationAtPosition(position - currentSegmentStartPosition);
			}
			currentSegmentStartPosition += fmcs.getDuration();
		}
		return -1;
	}
	

	
	/**
	 * Returns the segment containing the given position in the composition.
	 * @param position
	 * @return Composition segment, or null if none exists
	 */
	public FMCompositionSegment getCompositionSegmentAtPosition(int position) {
		List<FMCompositionSegment> segments = getCompositionSegments();
		int currentSegmentStartPosition = 0;
		for(FMCompositionSegment fmcs: segments) {
			if(position >= currentSegmentStartPosition &&
					position < currentSegmentStartPosition + fmcs.getDuration()) {
				return fmcs;
			}
			currentSegmentStartPosition += fmcs.getDuration();
		}
		return null;
	}
	
	/**
	 * Returns the time signature at the given position in the composition.
	 * @param position
	 * @return time signature
	 */
	public TimeSignature getTimeSignatureAtPosition(int position) {
		return getCompositionSegmentAtPosition(position).getTimeSignature();
	}
	
	/**
	 * Returns the time signature at the given position in the composition.
	 * @param position
	 * @return time signature as a string ("2/2", "4/8") or "" if no segment exists at that position
	 */
	public KeySignature getKeySignatureAtPosition(int position) {
		return getCompositionSegmentAtPosition(position).getKeySignature();
	}
	
	/**
	 * Returns the JMusic RhythmValue for the given FMNote RhythmValue
	 */
	public static double getJMRhythmValue(int fmRhythmValue) {
		return (fmRhythmValue*1.0/FMNote.QUARTER_NOTE);
	}
	
	/**
	 * Returns the FMNote RhythmValue for the given JMusic RhythmValue
	 */
	public static int getFMRhythmValue(double jmRhythmValue) {
		return (int)(jmRhythmValue*FMNote.QUARTER_NOTE + .5);
	}
	
	public class MeasureIterator implements Iterator<FMMeasure>{

		private Iterator<FMCompositionSegment> compositionSegmentIterator;
		private Iterator<FMMeasure> measureIterator;
		
		public MeasureIterator(FMComposition c) {
			compositionSegmentIterator = c.getCompositionSegments().iterator();
			if (compositionSegmentIterator.hasNext()) {
				measureIterator = compositionSegmentIterator.next().iterator();
			}
		}
		
		@Override
		public boolean hasNext() {
			if (measureIterator.hasNext()) {
				return true;
			}
			else if (compositionSegmentIterator.hasNext()) {
				measureIterator = compositionSegmentIterator.next().iterator();
				return hasNext();
			}
			return false;
		}

		@Override
		public FMMeasure next() {
			if (measureIterator.hasNext()) {
				return measureIterator.next();
			}
			else if (compositionSegmentIterator.hasNext()) {
				measureIterator = compositionSegmentIterator.next().iterator();
				return next();
			}
			throw new NoSuchElementException("You're done");
		}
		
	}

	/**
	 * Returns an iterator for the composition.
	 */
	@Override
	public Iterator<FMMeasure> iterator() {
		return new MeasureIterator(this);
	}
}
